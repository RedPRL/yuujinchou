{0 Design Principles of Yuujinchou}

{1 Explicit Sequencing}

One common mistake in other languages is the lack of explicit ordering between effectful operations such as hiding ({{!val:Yuujinchou.Language.except}except}), renaming ({{!val:Yuujinchou.Language.renaming}renaming}), and selecting ({{!val:Yuujinchou.Language.only}only}). The sequencing operator must be explicit, and we have {{!val:Yuujinchou.Language.seq}seq} for this purpose.

{1 Facilitation of API Patching}

One important use case is to patch existing libraries for backward compatibility. Often, minor revisions of the same API only add more bindings, and support of older versions can be done by supplying missing functions.

For example, if there is a missing function [is_prefix] in the [string] namespace, it should be easy to {e inject} such a function into the namespace. If multiple parts of the client are patching the same API, it should also be easy to take the union of all the patches.

Many of our decisions are guided by making API patching as easy as possible.

{1 Hierarchical Names}

We believe hierarchical names are essential in organizing top-level definitions, and perhaps even local definitions and record fields as well.

{2 Implicit Namespaces}

Contrary to most designs, the namespaces in this library are implicit. The "namespace" [a] is simply all bindings whose name has the prefix [a], or equivalently, the subtree rooted at [a]. The two names [a] and [a.x] can coexist and they are independent of each other. This might be our most surprising move to trivialize API patching. We might adjust this principle in the future, but so far it seems to be okay.

This principle has profound impact on the implementation---in particular, the union operation is effectively recursive. Consider the following pseudocode:
{v
section a {
  def x := 1
}
section b {
  section a {
    def y := 2
  }
}
modify_visible [union [any; renaming ["b"] []]]
v}
Both [a.x] and [a.y] will be available after the modification of the visible namespace because [b.a] and [a] will be recursively merge. In contrary, the binding [a.x] would be shadowed if it were OCaml code:
{[
module A =
  struct
    let x = 1
  end
module B =
  struct
    module A =
      struct
        let y = 2
      end
  end
open A (* [A.x] is gone *)
]}

The reason is that the previous pseudocode is equivalent to the following:
{v
def a.x = 1
def b.a.y = 2
modify_visible [union [any; renaming ["b"] []]]
v}
where the union of the original namespace (via {{!val:Yuujinchou.Language.any}any}), which contains [a.x] and [b.a.y], and the output of {{!val:Yuujinchou.Language.renaming}renaming}, which contains [a.y], results into a namespace with [a.x], [a.y], and [b.a.y]. The binding [a.y] does not hide [a.x] because there is no explicit namespace [a] to hide [a.x]. In comparison, there was an OCaml module [A] to shadow another module [A] and its member [A.x]. This radically different treatment makes it easy to patch a deeply nested namespace with one union operator.

{2 Operations on Subtrees}

To recover efficient group operations on implicit namespaces as one might expect for explicit namespaces, all modifiers in {{!Yuujinchou.Language}Language} work on subtrees instead of individual bindings. For example, [only ["x"]] will select {e all} bindings with the prefix [x], not just the binding [x]. Therefore, in most cases, one can pretend that namespaces exist. (We tried providing modifiers for both subtrees and individual bindings, but the ones for individual bindings seem useless.)

{2 Side Notes on Modules}

There are fundamental differences between ML-style modules (records) and namespaces: A module (or a record) is typed, in the sense that there will be a single type assigned to it. The typedness enables considering an abstract module of a module type. Signatures and functors in Standard ML and OCaml follow this approach. On the other hand, a namespace is untyped, which forbids the notion of abstract namespaces but admits flexible operations. Despite the amount of prior work on this topic (e.g., see the {{:https://doi.org/10.1145/1086365.1086371}ICFP paper {i An expressive language of signatures} by Norman Ramsey, Kathleen Fisher, and Paul Govereau}), it seems difficult to have a typed grouping mechanism that supports all flexible operations. As a result, equating the more restricted, typed grouping mechanism with the potentially freer, untyped mechanism might unnecessarily limit the latter; both Standard ML and OCaml arguably suffer from this. In the context of proof assistants, one should also recognize that top-level definitions might not have a type in an internalized universe. (The [module]s in Haskell and Agda are namespaces for the discussion here.) Instead, having separate notions of namespaces and modules/records, as in C++ and our proof assistant cooltt, could lead to a better design.

{1 Guards against Typos}

{2 No No-Ops}

Hiding, renaming, selecting, and excluding modifiers must match at least one existing binding. For example, if there is no binding with the prefix [x], then selecting the namespace rooted at [x] should fail or at least produce a warning. The reason is that the lack of matching bindings strongly indicates a typo. In this library, such an error will trigger the effect {{!field:Yuujinchou.Modifier.not_found}not_found}.

As a consequence of this principle, a modifier cannot be understood as a function from an old name to a set of new names, but a function from an old namespace (implemented as a {{!module:Yuujinchou.Trie}trie} in this library) to a new namespace. Otherwise, it is difficult or impossible to detect whether there are unexpected no-ops.

{2 Explicit Unions}

Arbitrary unions should be allowed for easy API patching, but they should not happen without using [import], [include], [section], or a dedicated operator. We have {{!val:Yuujinchou.Language.union}union} dedicated to the union operation.

One interesting case is renaming. According to this principle, the renaming from [x] to [y] should either (1) drop all bindings with the prefix [y] or (2) simply err when there exists at least one binding with the prefix [y]. To facilitate API patching, however, we silently drop bindings with the prefix [y] so that users can more easily provide a group of new bindings without worrying whether such bindings already exist in the newer version of the library.

In the event that there is accidental silent dropping due to renaming, it is likely that the expected bindings will be missing and the code will not scope check, and thus the user is still protected.

{1 Decoupling from Export Control}

In many designs, the name modifiers are coupled with export control (public v.s. private). We believe these two concerns can be completely separated. As a proof, we have built {{!module:Yuujinchou.Scope}Scope} that handles visible and export namespaces, on top of the modifier engine {{!module:Yuujinchou.Modifier}Modifier} that is oblivious to how it's used.

{1 Expressiveness and Extensibility}

The modifier language should be able to approximate all features in popular programming languages. Language-specific features (such as phases in Racket) can be implemented using the modifier {{!val:Yuujinchou.Language.hook}hook}.

{1 Conciseness and Compositionality}

The core language should be small, possibly exploiting the compositionality to remove redundent constructors. For example, the core language does not have {{!val:Yuujinchou.Language.except}except}[ p] because it can be defined as {{!val:Yuujinchou.Language.in_}in_}[ p ]{{!val:Yuujinchou.Language.none}none}. This, however, does not mean the number of constructors should be theoretically minimal: For example, in earlier versions of Yuujinchou, we have a "split" modifier that applies one modifier to a subtree and another to all bindings outside the subtree, but such a "mega-modifier" only complicates the core language and the engine implementation. To the extreme, one can have one single constructor in the core language to handle all features, but that would not be helpful.

The current design has seven constructors in the core languages:
- {{!val:Yuujinchou.Language.only}only}: selecting
- {{!val:Yuujinchou.Language.none}none}: dropping everything
- {{!val:Yuujinchou.Language.in_}in_}: scoping
- {{!val:Yuujinchou.Language.renaming}renaming}: renaming
- {{!val:Yuujinchou.Language.seq}seq}: sequencing
- {{!val:Yuujinchou.Language.union}union}: union
- {{!val:Yuujinchou.Language.hook}hook}: custom hooks

{1 Algebraic Effects}

We believe algebraic effects are the future!
