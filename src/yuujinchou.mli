(** The {!module:Pattern} module defines the patterns. *)
module Pattern :
sig
  (** {1 Pattern Type } *)

  (** The type of patterns, parametrized by the attribute type. See {!attributes} for more information about attributes. *)
  type 'a pattern

  (**
     The pattern type is abstract---you should build a pattern using the following builders. The detail of the core language is at the end of this page. Use {!val:Action.run} to execute a pattern.
  *)

  (** {2 Hierarchical Names} *)

  (** The type of names. *)
  type path = string list

  (**
     We assume names are hierarchical and can be encoded as lists of strings. For example, the name [a.b.c] is represented as the following OCaml list:
     {[
       ["a"; "b"; "c"]
     ]}
  *)

  (** {1 Pattern Builders} *)

  (** {2 Basics} *)

  (** The pattern that matches any name. *)
  val any : 'a pattern

  (** The pattern that matches no names. *)
  val none : 'a pattern

  (** The pattern [id x] that matches the name [x] and nothing else. *)
  val id : path -> 'a pattern

  (** The wildcard pattern that matches everything except for the empty name (the empty list [[]]). *)
  val wildcard : 'a pattern

  (** The pattern that only matches the empty name (the empty list [[]]). *)
  val root : 'a pattern

  (** Scoping a pattern with a prefix. For example, [scope p (id x)] is equivalent to [id (p @ x)] *)
  val scope : path -> 'a pattern -> 'a pattern

  (** The pattern that matches any name with the given prefix. The pattern [prefix p] is equivalent to [scope p any]. *)
  val prefix : path -> 'a pattern

  (** {2 Negation} *)

  (** The pattern that skips the specified name. *)
  val skip : path -> 'a pattern

  (** The pattern that skips any name with the specified prefix. *)
  val skip_prefix : path -> 'a pattern

  (** {2 Renaming} *)

  (** The pattern that matches only the specified name and replaces it. *)
  val renaming : path -> path -> 'a pattern

  (** The pattern that matches any name with the given prefix and replaces the prefix. *)
  val renaming_prefix : path -> path -> 'a pattern

  (** Scoping a pattern and rename the prefix. *)
  val renaming_scope : path -> path -> 'a pattern -> 'a pattern

  (** {2:attributes Attributes} *)

  (**
     Attributes are custom tags attached to matched names. For example, you could attach [`Public] or [`Private] to names when implementing the import statement. You need to supply a default value and a lattice structure for your attribute type [t] when running the pattern using {!Action.run}:

     {ol

      {li

      A default value of type [t].

      The default attribute attached to the new names until the engine encounters the pattern created via {!attributes} that explicitly sets a new default attribute.}

      {li

      A join operator of type [t -> t -> t].

      An operator to resolve the conflicting attributes by taking their "union". The exact meaning of "union" depends on the lattice structure. This is for reconciling conflicting attributes when running patterns generated by {!val:seq}, {!val:seq_filter} or {!val:join}.}

     {li
     A meet operator of type [t -> t -> t].

     An operator to resolve the conflicting attributes by taking their "intersection". The exact meaning of "intersection" depends on the lattice structure. This is for reconciling conflicting attributes when running patterns generated by {!val:meet}.
      }}

     For example, when implementing the traditional import statement, the attribute type can be
     {[
       type attr = [ `Public | `Private ]
     ]}
     and then the meet and join operators can be implemented as follows:
     {[
       let join_attr a1 a2 =
         match a1, a2 with
         | `Public, _ | _, `Public -> `Public
         | `Private, `Private -> `Private

       let meet_attr a1 a2 =
         match a1, a2 with
         | `Private, _ | _, `Private -> `Private
         | `Public, `Public -> `Public
     ]}
     In other words, [`Pubilc] is treated as the top element and [`Private] is the bottom element. The rationale is that if a name is simultanously imported as a public name (to be re-exported) and a private name (not to be re-exported), then in most programming languages it {e will} be re-exported. This suggests that the join operator should outputs [`Public] whenever one of the inputs is [`Public]. It then makes sense to make the meet operator the dual of the join operator.

     The following pattern changes the default attribute before running the subpattern:
  *)

  (** The pattern [attr a p] will assigns the default attribute to [a] and then runs the pattern [p]. *)
  val attr : 'a -> 'a pattern -> 'a pattern

  (** {2 Sequencing} *)

  (** The pattern [seq [p0; p1; p2; ...; pn]] runs the patterns [p0], [p1], [p2], ..., [pn] in order.

      If [pi] triggers the renaming, then the new names are used in the subsequent patterns. A name is considered matched if it is matched by any pattern during the process. Inconsistent attributes on the same name are resolved by the provided [join] operator. See {!attributes}. *)
  val seq : 'a pattern list -> 'a pattern

  (** The pattern [seq_filter [p0; p1; p2; ...; pn]] is almost the same as [seq [p0; p1; p2; ...; pn]], except that a name is considered matched only when it is matched (and potentially renamed) by all the patterns in the list. Inconsistent attributes on the same name are resolved by the provided [join] operator. See {!attributes}. *)
  val seq_filter : 'a pattern list -> 'a pattern

  (** {2 Logical Connectives} *)

  (** [join [p0; p1; p2; ...; pn]] is the join of the patterns [p0], [p1], [p2], ..., [pn]. A name is considered matched when it is matched by any subpattern. Inconsistent attributes assigned by the subpatterns are resolved by the provided [join] operator on attributes. See {!attributes}. *)
  val join : 'a pattern list -> 'a pattern

  (** [meet [p0; p1; p2; ...; pn]] is the meet of a non-empty list of patterns [p0], [p1], [p2], ..., [pn]. If the list is empty, {!val:meet} will raise [Invalid_argument]. A name is considered matched only when it is matched by all the subpatterns. If a name is matched in all subpatterns, but the intersection of the new names is empty, then the name is still considered matched, with an empty set of new names. Inconsistent attributes assigned by the subpatterns are resolved by the provided [meet] operator on attributes. See {!attributes}. *)
  val meet : 'a pattern list -> 'a pattern

  (** {2 Unsafe Builders} *)

  (** [unsafe_meet l] is the same as [meet l] except that it does not check whether the list is empty. This might be useful to build subpatterns that would temporarily violate the invariant. See {!invariants}. *)
  val unsafe_meet : 'a pattern list -> 'a pattern

  (** [unsafe_inv p] negates the meaning of pattern [p]. This might be useful to build more efficient patterns by temporarily violating the invariants. Please read {!core} for more the detail. See also {!invariants}. *)
  val unsafe_inv : 'a pattern -> 'a pattern

  (** {1 Pretty printers } *)

  (** Pretty printer for {!type:path}. *)
  val pp_path : Format.formatter -> path -> unit

  (** Pretty printer for {!type:pattern}. *)
  val pp_pattern : (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a pattern -> unit

  (** {1:core Core Language}

      Here is the current implementation of {!type:pattern}:
      {[
        type 'a pattern =
          | PatWildcard
          | PatScope of path * path option * 'a pattern
          | PatSeq of 'a pattern list
          | PatInv of 'a pattern
          | PatJoin of 'a pattern list
          | PatAttr of 'a * 'a pattern
      ]}

      We will explain each combinator, one by one. However, it is essential to know the possible results of pattern matching and {e modes} first.

      {2 Results}

      The result of pattern matching is one of the following:

        {ol
        {li [Ok `NoMatch]: the pattern runs without errors but does not match the name.}
        {li [Ok `Matched [(name_1, attr_1); (name_2, attr_2); ...]]: the pattern matches the name and outputs its new names tagged with attributes. (See {!attributes}) It is possible that the set of new names is empty despite the old name being matched because we support the intersection operator {!val:meet}.}
        {li [Error err]: the pattern is ill-formed, violating the invariants described in {!invariants}.}
        }

      See {!type:Action.result_}, {!type:Action.error} and {!val:Action.run}.

      {2 Modes}

      There are two modes of the pattern matching engine: the {e normal} mode and the {e inverse} mode. The motivation to have the inverse mode is to implement the patterns that hide names from being imported. Think about the pattern [id ["a"; "b"]], which would normally select the name [a.b] from the imported content. Its dual meaning---selecting everything {e other than} the name [a.b]---is exactly the hiding operator we are looking for. The inverse mode has been extended to the entire core language and significantly reduce the number of combinators. It is recommended to study how the core language works under the normal mode first.

      {2 Combinators}

      {3 Wildcard ([PatWildcard])}

      The wildcard pattern [PatWildcard] under the normal mode matches every name except for the root (the empty list [[]]). The same pattern under the inverse mode matches nothing but the root (the empty list [[]]). In either case, if a name [p] is matched, then the output is [Ok (Match [p, a])] where [a] is the inherited default attribute.

      {3 Scope Renaming ([PatScope])}

      The pattern [PatScope (p, None, pat)] under the normal mode identifies any name with the prefix [p] and then runs [pat] against the residual part of the name. For example, [PatScope (["a"; "b"], None, PatWildcard)] will first identify the name [a.b.c] (represented by [["a"; "b"; "c"]]) because it has the prefix [["a"; "b"]], and then the pattern [PatWildcard] will match the remaining part [c]. The same pattern under the inverse mode will match any name whose prefix is {e not} [p], and any name that has the prefix [p] but fails to match [pat] after removing the prefix [p].

      The pattern [PatScope (p, Some r, pattern)] is the same as [PatScope (p, None, pattern)] expect that the prefix [p], if matched, will be replaced by [r]. The same pattern under the inverse mode will result into an error because the replacement [r] would not be used.

      {3 Sequencing ([PatSeq])}

      The pattern [PatSeq [pat_1; pat_2; ...; pat_n]] under the normal mode runs the patterns [pat_1], [pat_2], ..., [pat_n] in order. New names generated by previous patterns (possibly through the scope renaming operator [PatScope]) are used in later patterns. A name is matched if it is matched by any pattern in the sequence during the process. It is possible that a name is renamed into multiple names during the process, and these renamings are merged by taking the union of all possible renamings, where conflicting attributes are resolved by the join operation in the attribute lattice. As a special case, [PatSeq []] under the normal mode matches nothing.

      The same pattern [PatSeq [pat_1; pat_2; ...; pat_n]] under the inverse mode also runs the patterns [pat_1], [pat_2], ..., [pat_n] in order, but with a twist: a name is matched only if it is matched by all patterns in the sequence. Overlapping renamings and conflicting attributes are resolved by the unions and joins. As a special case, [PatSeq []] under the inverse mode matches any name, including the root (represented by [[]]), which is different from the wildcard pattern ([PatWildcard]).

      {3 Mode Inversion ([PatInv])}

      The pattern [PatInv pat] flips the current mode of the engine (from the normal mode to the inverse mode or vice versa) and proceed with the pattern [pat].

      {3 Join and Meet ([PatJoin])}

      [PatJoin [pat_1; pat_2; ...; pat_n]] under the normal mode runs the subpatterns independently and takes the join of the renaming relations. The same pattern under the inverse mode takes the meet of the renaming relations instead. However, the pattern [PatJoin []] under the inverse mode will result into an error because there is not an unit of the meet of patterns.

      There is one trick case about the meet operation: Assume we have two different names [x] and [y]. The meet of [`Matched [x, a]] and [`Matched [y, a]] is [`Matched []], not [`NoMatch]. It means the name is matched but there are no new names for it.

      {3 Attribute Assignment ([PatAttr])}

      The pattern [PatAttr (attr, pat)] sets the default attribute to [attr] before running the pattern [pat]. It does not change the mode of the engine.


      {2:invariants Invariants}

      Patterns involving renaming (e.g., [PatScope (p, Some r, pattern)]) and the empty join pattern [PatJoin []] should not be run under the inverse mode.
  *)
end

(** The {!module:Action} module implements the engine runnig the patterns. *)
module Action :
sig
  open Pattern

  (** {1 Types} *)

  (** The result type of pattern matching. *)
  type 'a result_ = [
    | `NoMatch (** The pattern does not match the name. *)
    | `Matched of (path * 'a) list (** The pattern matches the name, with a list of tagged new names. *)
  ]

  (** The type of error messages describing the violated invariants. See {!invariants}. It should be impossible to violate these invariants unless {!val:Pattern.unsafe_meet} or {!val:Pattern.unsafe_inv} is used.

      The pattern embedded in the error message is the fragment that violates the invariant. The pattern [pat] in [EmptyMeet pat] is not useful on its own---we all know it must be [PatJoin []]---but it facilitates using or-patterns in error handling. *)
  type 'a error =
    | ReplacementNotUsed of 'a pattern (** Renaming patterns are run under the inverse mode. *)
    | EmptyMeet of 'a pattern (** The join patterns under the inverse mode (or, equivalently, the meet patterns under the normal mode) have no subpatterns. *)

  (** {1 Engines} *)

  (** The pattern matching engine.

      @param default The default attribute for the engine to start with. See {!Pattern.attributes}.
      @param join The join operator to resolve conflicting attributes. See {!Pattern.attributes}.
      @param meet The meet operator to resolve conflicting attributes. See {!Pattern.attributes}.
  *)
  val run : default:'a -> join:('a -> 'a -> 'a) -> meet:('a->'a->'a) -> 'a pattern -> path -> ('a result_, 'a error) result

  (** The engine specialized to [unit pattern] where the attribute type is [unit]. *)
  val run_ : unit pattern -> path -> (unit result_, unit error) result

  (** Check whether any invariant is violated. See {!Pattern.invariants}. *)
  val check : 'a pattern -> (unit, 'a error) result

  (** {1 Pretty printers} *)

  (** Pretty printer for {!type:result_}. *)
  val pp_result_ : (Format.formatter -> 'a -> unit) -> Format.formatter -> 'a result_ -> unit

  (** Pretty printer for results of pattern matching. *)
  val pp_result : (Format.formatter -> 'a -> unit) -> Format.formatter -> ('a result_, 'a error) result -> unit

  (** Pretty printer for results of checking patterns. *)
  val pp_check_result : (Format.formatter -> 'a -> unit) -> Format.formatter -> (unit, 'a error) result -> unit
end

(**
   {1 Introduction}

   {b Yuujinchou} is an OCaml combinator library for manipulating names. It was motivated by the `import` or `include` statements present in almost all programming languages. Here are some examples of such statements:

   {v open import M -- Agda v}

   {v import foo # Python v}

   The ability to import content from other files helps organize code. However, it also brings up new design issues: how could programmers prevent imported content from colliding or shadowing the existing content in the current scope? For example, maybe in the current scope, we have defined a function called [test], and do not want to import another function also called [test]. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:

   {v
open import M renaming (a to b) public
-- renaming a to b, and then re-exporting the content
   v}

   {v
import foo as bar
# putting content of foo under the prefix bar
   v}

   We can treat hiding or renaming as a partial function from names to names. I took this aspect seriously and designed this combinator library---a concise yet powerful (perhaps overkilling) language for manipulating names in programming languages.

   {1 Applications}

   This library was motivated by the import mechanism in most programming languages, but can be used in any situation involving selecting names. For example, during interactive theorem proving, perhaps you want to unfold some definitions but not others. This library gives you a powerful language to support fancy name selection.

   {1 Organization}

   The code is split into two parts: {!module:Pattern} and {!module:Action}.

   {1  Namespace Support}

   This library intends to treat a namespace as the prefix of a group of names. That is, there is no namespace [a], but only a group of unrelated names that happen to have the prefix [a].

   Note that namespaces (name prefixes of unrelated declarations) are different from modules (groups of declarations that are bound together). This library does not provide special support for modules (yet).

   {1 Examples}

   {2 Haskell}

   {v
import Mod -- x is available an both x and Mod.x
   v}
   {[
     join [any; renaming_prefix [] ["Mod"]]
   ]}


   {v
import Mod (x,y)
   v}
   {[
     join [id ["x"]; id ["y"]]
   ]}


   {v
import qualified Mod
   v}
   {[
     join [renaming_prefix [] ["Mod"]]
   ]}

   {v
import qualified Mod hiding (x,y)
   v}
   {[
     renaming_scope [] ["Mod"] @@ meet [skip ["x"]; skip ["y"]]
   ]}

   {1 What is "Yuujinchou"?}

   "Yuujinchou" is the transliteration of "友人帳" in Japanese, which literally means "book of friends". The book is a powerful booklet that collects {e real names (真名)} of youkais (妖怪) (supernatural and spiritual monsters) in the manga and anime Natsume Yuujinchou (夏目友人帳). These real names can be used to control youkais, but the protagonist decided to return the names to youkais. The plot is about meeting different youkais during the journey.

   This library is also about using names to summon monsters.

   The transliteration is in the Wāpuro style to work around the name restriction; otherwise, its Hepburn romanization would be "Yūjin-chō".

*)
