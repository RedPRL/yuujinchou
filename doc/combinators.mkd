# Combinators

Here is the internal type of patterns:
```ocaml
type path = string list
type 'a pattern =
  | PatWildcard
  | PatScope of path * path option * 'a pattern
  | PatSeq of 'a pattern list
  | PatInv of 'a pattern
  | PatJoin of 'a pattern list
  | PatAttr of 'a * 'a pattern
```

We will explain each combinator, one by one.

## Wildcard (`PatWildcard`)

The wildcard pattern `PatWildcard` under the normal mode matches every name except for the root (the empty list `[]`). The same pattern under the inverse mode matches nothing but the root (the empty list `[]`). In either case, if a name `p` is matched, then the output is `Ok (Match [p, attr])` where `attr` is the inherited default attribute.

## Scope Renaming (`PatScope`)

The pattern `PatScope (p, None, pattern)` under the normal mode identifies any name with the prefix `p` and then runs `pattern` against the residual part of the name. For example, `Pat (["a"; "b"], PatWildcard)` will first identify the name `a.b.c` (represented by `["a"; "b"; "c"]`) because it has the prefix `["a"; "b"]`, and then the pattern `PatWildcard` will match the remaining part `c`. The same pattern under the inverse mode will match any name whose prefix is _not_ `p`, and any name that has the prefix `p` but fails to match `pattern` after removing the prefix `p`.

The pattern `PatScope (p, Some r, pattern)` is the same as `PatScope (p, None, pattern)` expect that the prefix `p`, if matched, will be replaced by `r`. The same pattern under the inverse mode will result into an error because the replacement `r` would not be used.

## Sequencing (`PatSeq`)

The pattern `PatSeq [pattern_1; pattern_2; ...; pattern_n]` under the normal mode runs the patterns `pattern_1`, `pattern_2`, ..., `pattern_n` in order. New names generated by previous patterns (possibly through the scope renaming operator `PatScope`) are used in later patterns. A name is matched if it is matched by any pattern in the sequence. It is possible that a name is renamed into multiple names during the process, and these renamings are merged by taking the union of all possible renamings, where conflicting attributes are resolved by the join operation of the attribute lattice. As a special case, `PatSeq []` under the normal mode matches nothing.

The pattern `PatSeq [pattern_1; pattern_2; ...; pattern_n]` under the inverse mode also runs the patterns `pattern_1`, `pattern_2`, ..., `pattern_n` in order, but with a twist: a name is matched only if it is matched by all patterns in the sequence. Overlapping renamings and conflicting attributes are resolved by the unions and joins as well. As a special case, `PatSeq []` under the inverse mode matches any name, including the root (represented by `[]`), which is different from the wildcard pattern (`PatWildcard`).

## Mode Inversion (`PatInv`)

The pattern `PatInv pat` flips the current mode of the engine (from the normal mode to the inverse mode or vice versa) and proceed with the pattern `pat`.

## Attribute Assignment (`PatAttr`)

The pattern `PatAttr (attr, pat)` sets the default attribute to `attr` before running the pattern `pat`.

## Join and Meet (`PatJoin`)

`PatJoin [pattern_1; pattern_2; ...; pattern_n]` under the normal mode runs the subpatterns independently and takes the join of the renaming relations. The same pattern under the inverse mode takes the meet of the renaming relations instead. However, the pattern `PatJoin []` under the inverse mode will result into an error because there is not an unit of the meet of patterns.

There is one trick case about the meet operation: Assume we have two different names `x` and `y`. The meet of ``` `Matched [x, Public]``` and ``` `Matched [y, Public]``` is ``` `Matched []```, not ``` `NoMatch```. It means the name is matched but there are no new names for it.

