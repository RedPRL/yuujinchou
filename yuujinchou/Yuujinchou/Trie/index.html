<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Trie (yuujinchou.Yuujinchou.Trie)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">yuujinchou</a> &#x00BB; <a href="../index.html">Yuujinchou</a> &#x00BB; Trie</nav><header class="odoc-preamble"><h1>Module <code><span>Yuujinchou.Trie</span></code></h1><p>The <a href="#"><code>Trie</code></a> module implements mappings from paths to values that support efficient subtree operations.</p></header><nav class="odoc-toc"><ul><li><a href="#types">Types</a></li><li><a href="#basic-operations">Basic Operations</a></li><li><a href="#finding-values">Finding Values</a></li><li><a href="#mapping-and-filtering">Mapping and Filtering</a></li><li><a href="#updating">Updating</a></li><li><a href="#union">Union</a></li><li><a href="#separation">Separation</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#tags">Tags</a></li></ul></nav><div class="odoc-content"><h2 id="types"><a href="#types" class="anchor"></a>Types</h2><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span><span> = <span>string list</span></span></code></div><div class="spec-doc"><p>The type of hierarchical names. The name <code>x.y.z</code> is represented by the OCaml list <code>[&quot;x&quot;; &quot;y&quot;; &quot;z&quot;]</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-bwd_path"><a href="#type-bwd_path" class="anchor"></a><code><span><span class="keyword">type</span> bwd_path</span><span> = <span>string <span class="xref-unresolved">Bwd</span>.bwd</span></span></code></div><div class="spec-doc"><p>The type of hierarchical names, but using backward lists. The name <code>x.y.z</code> is represented by the backward list <code>Emp #&lt; &quot;x&quot; #&lt; &quot;y&quot; #&lt; &quot;z&quot;</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>(!+'data, !+'tag) t</span></span></code></div><div class="spec-doc"><p>The abstract type of a trie. <code>'data</code> represents the information surviving retagging, and <code>'tag</code> represents the information to be reset during retagging. See <a href="#val-retag"><code>retag</code></a>, which could reset all tags in O(1) time while keeping data intact. A possible usage when making a proof assistant is to put top-level definitions into <code>'data</code> and identities of the import statements into <code>'tag</code> for efficient detection of unused imports.</p></div></div><h2 id="basic-operations"><a href="#basic-operations" class="anchor"></a>Basic Operations</h2><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty trie.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check whether the trie is empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-root"><a href="#val-root" class="anchor"></a><code><span><span class="keyword">val</span> root : <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>root (d, t)</code> makes a trie with the only one binding: the root and its associated data <code>d</code> and tag <code>t</code>. It is equivalent to <a href="#val-root_opt"><code>root_opt</code></a><code> (Some (d, t))</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-root_opt"><a href="#val-root_opt" class="anchor"></a><code><span><span class="keyword">val</span> root_opt : <span><span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>root_opt v</code> is equivalent to <code>match v with None -&gt; </code><a href="#val-empty"><code>empty</code></a><code> | Some v -&gt; </code><a href="#val-root"><code>root</code></a><code> v</code>. In other words, <code>root_opt None</code> will make an empty trie and <code>root_opt (Some (d, t))</code> will make a trie with only one binding: the root associated with the data <code>d</code> and the tag <code>t</code>. If the input is always <code>Some v</code>, use <a href="#val-root"><code>root</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-prefix"><a href="#val-prefix" class="anchor"></a><code><span><span class="keyword">val</span> prefix : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>prefix p t</code> makes a minimum trie with <code>t</code> rooted at <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span>(<a href="#type-path">path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>singleton (p, (d, t))</code> makes a trie with the only binding: <code>p</code> and its associated data <code>d</code> and tag <code>t</code>. It is equivalent to <a href="#val-prefix"><code>prefix</code></a><code> p @@ </code><a href="#val-root"><code>root</code></a><code> (d, t)</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : 
  <span><span>(<span><span class="type-var">'data</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'data</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>equal eq_data eq_tag t1 t2</code> checks whether two tries are equal.</p></div></div><h2 id="finding-values"><a href="#finding-values" class="anchor"></a>Finding Values</h2><div class="odoc-spec"><div class="spec value anchored" id="val-find_subtree"><a href="#val-find_subtree" class="anchor"></a><code><span><span class="keyword">val</span> find_subtree : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>find_subtree p t</code> returns the subtree rooted at <code>p</code>.</p><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>The subtree with all the bindings under <code>p</code>, including the binding at <code>p</code> itself (which will be the root). If there are no such bindings with the prefix <code>p</code>, an empty trie is returned.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_singleton"><a href="#val-find_singleton" class="anchor"></a><code><span><span class="keyword">val</span> find_singleton : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_singleton p t</code> returns the data and tag at <code>p</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_root"><a href="#val-find_root" class="anchor"></a><code><span><span class="keyword">val</span> find_root : <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_root t</code> returns the data and tag at the root. This is equivalent to <a href="#val-find_singleton"><code>find_singleton</code></a><code> [] t</code>.</p></div></div><h2 id="mapping-and-filtering"><a href="#mapping-and-filtering" class="anchor"></a>Mapping and Filtering</h2><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>iter f t</code> applies the function <code>f</code> to each data and tag in the trie.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>f</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data1</span> * <span class="type-var">'tag1</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data2</span> * <span class="type-var">'tag2</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data1</span>, <span class="type-var">'tag1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data2</span>, <span class="type-var">'tag2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f trie</code> applies the function <code>f</code> to each data and tag in the trie.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>f</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f trie</code> removes all data <code>d</code> with tag <code>t</code> at path <code>p</code> such that <code>f p (d, t)</code> returns <code>false</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>f</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data1</span> * <span class="type-var">'tag1</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data2</span> * <span class="type-var">'tag2</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data1</span>, <span class="type-var">'tag1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data2</span>, <span class="type-var">'tag2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map f trie</code> applies the function <code>f</code> to each data <code>d</code> with tag <code>t</code> at <code>p</code> in <code>trie</code>. If <code>f p (d, t)</code> returns <code>None</code>, then the binding will be removed from the trie. Otherwise, if <code>f v</code> returns <code>Some d'</code>, then the data will be replaced by <code>d'</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>f</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><h2 id="updating"><a href="#updating" class="anchor"></a>Updating</h2><div class="odoc-spec"><div class="spec value anchored" id="val-update_subtree"><a href="#val-update_subtree" class="anchor"></a><code><span><span class="keyword">val</span> update_subtree : 
  <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_subtree p f t</code> replaces the subtree <code>t'</code> rooted at <code>p</code> in <code>t</code> with <code>f t'</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_singleton"><a href="#val-update_singleton" class="anchor"></a><code><span><span class="keyword">val</span> update_singleton : 
  <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_singleton p f trie</code> replaces the data and tag at <code>p</code> in <code>trie</code> with the result of <code>f</code>. If there was no binding at <code>p</code>, <code>f None</code> is evaluated. Otherwise, <code>f (Some (d, t))</code> is used where <code>d</code> and <code>t</code> are the data and the tag. If the result is <code>None</code>, the old binding at <code>p</code> (if any) is removed. Otherwise, if the result is <code>Some (d', t')</code>, the data and the tag at <code>p</code> are replaced by <code>d'</code> and <code>t'</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_root"><a href="#val-update_root" class="anchor"></a><code><span><span class="keyword">val</span> update_root : 
  <span><span>(<span><span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_root f t</code> updates the value at root with <code>f</code>. It is equivalent to <a href="#val-update_singleton"><code>update_singleton</code></a><code> [] f t</code>.</p></div></div><h2 id="union"><a href="#union" class="anchor"></a>Union</h2><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union merger t1 t2</code> merges two tries <code>t1</code> and <code>t2</code>. If both tries have a binding at the same path <code>p</code>, it will call <code>merger p x y</code> to reconcile the values <code>x</code> from <code>t1</code> and <code>y</code> from <code>t2</code> that are both bound at the <code>path</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union_subtree"><a href="#val-union_subtree" class="anchor"></a><code><span><span class="keyword">val</span> union_subtree : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-path">path</a> * <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union_subtree merger t1 (path, t2)</code> is equivalent to <a href="#val-union"><code>union</code></a><code> merger t1 (prefix path t2)</code>, but potentially more efficient.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union_singleton"><a href="#val-union_singleton" class="anchor"></a><code><span><span class="keyword">val</span> union_singleton : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-path">path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union_singleton merger t binding</code> is equivalent to <a href="#val-union"><code>union</code></a><code> merger t1 (singleton binding)</code>, but potentially more efficient.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-union_root"><a href="#val-union_root" class="anchor"></a><code><span><span class="keyword">val</span> union_root : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>union_root merger t r</code> is equivalent to <a href="#val-union_singleton"><code>union_singleton</code></a><code> merger t ([], r)</code>, but potentially more efficient.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><h2 id="separation"><a href="#separation" class="anchor"></a>Separation</h2><div class="odoc-spec"><div class="spec value anchored" id="val-detach_subtree"><a href="#val-detach_subtree" class="anchor"></a><code><span><span class="keyword">val</span> detach_subtree : 
  <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> * <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>detach_subtree p t</code> detaches the subtree at <code>p</code> from the main trie and returns both the subtree and the remaining trie (in that order). If <code>detach p t</code> returns <code>t1, t2</code>, then <a href="#val-union_subtree"><code>union_subtree</code></a><code> m t2 (p, t1)</code> should be equivalent to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-detach_singleton"><a href="#val-detach_singleton" class="anchor"></a><code><span><span class="keyword">val</span> detach_singleton : 
  <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span> * <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>detach_singleton p t</code> detaches the binding at <code>p</code> from the main trie and returns both the binding and the remaining trie. If <code>detach p t</code> returns <code>b, t'</code>, then <a href="#val-union_subtree"><code>union_subtree</code></a><code> m t' (p, </code><a href="#val-root_opt"><code>root_opt</code></a><code> b)</code> should be equivalent to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-detach_root"><a href="#val-detach_root" class="anchor"></a><code><span><span class="keyword">val</span> detach_root : <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> option</span> * <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>detach_root t</code> detaches the binding at the root of and returns both the binding and the remaining trie. It is equivalent to <a href="#val-detach_singleton"><code>detach_singleton</code></a><code> [] t</code>.</p></div></div><h2 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-path">path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq t</code> traverses through the trie <code>t</code> in the lexicographical order.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path in the output. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq_with_bwd_paths"><a href="#val-to_seq_with_bwd_paths" class="anchor"></a><code><span><span class="keyword">val</span> to_seq_with_bwd_paths : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="#type-bwd_path">bwd_path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq_with_bwd_paths</code> is like <a href="#val-to_seq"><code>to_seq</code></a>, but with paths represented as backward lists. This is potentially more efficient than <a href="#val-to_seq"><code>to_seq</code></a> because the conversion from a backward list to a forward list takes linear time.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path in the output. The default is the empty prefix (<code>Emp</code>).</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq_values"><a href="#val-to_seq_values" class="anchor"></a><code><span><span class="keyword">val</span> to_seq_values : <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq_values t</code> traverses through the trie <code>t</code> in the lexicographical order but only returns the associated data and tags. This is potentially more efficient than <a href="#val-to_seq"><code>to_seq</code></a> because the conversion of paths from backward lists to forward lists is skipped.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<a href="#type-path">path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq s</code> inserts bindings <code>(p, d)</code> into an empty trie, one by one, using <a href="#val-union_singleton"><code>union_singleton</code></a>. Later bindings will shadow previous ones if the paths of bindings are not unique.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq_with_merger"><a href="#val-of_seq_with_merger" class="anchor"></a><code><span><span class="keyword">val</span> of_seq_with_merger : 
  <span><span class="optlabel">?prefix</span>:<a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-bwd_path">bwd_path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-path">path</a> * <span>(<span class="type-var">'data</span> * <span class="type-var">'tag</span>)</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq_with_merger merger s</code> inserts bindings <code>(p, d)</code> into an empty trie, one by one, using <a href="#val-union_singleton"><code>union_singleton</code></a>. Bindings with the same path are resolved using <code>merger</code> instead of silent shadowing.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">prefix</span> <p>The prefix prepended to any path sent to <code>merger</code>. The default is the empty prefix (<code>Emp</code>). Note that <code>prefix</code> does not directly affect the output trie, only the argument to <code>merger</code>.</p></li></ul></div></div><h2 id="tags"><a href="#tags" class="anchor"></a>Tags</h2><div class="odoc-spec"><div class="spec type anchored" id="type-untagged"><a href="#type-untagged" class="anchor"></a><code><span><span class="keyword">type</span> <span>'data untagged</span></span><span> = <span><span>(<span class="type-var">'data</span>, unit)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Untagged tries (where all tags are <code>()</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_tag"><a href="#val-map_tag" class="anchor"></a><code><span><span class="keyword">val</span> map_tag : <span><span>(<span><span class="type-var">'tag1</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'tag2</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag1</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag2</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_tag f trie</code> applies <code>f</code> to all tags within <code>trie</code>, which is equivalent to <a href="#val-map"><code>map</code></a><code> (fun _ (d, t) -&gt; (d, f t)) trie</code> but can often be more efficient. The data remain intact. Note that if <code>f</code> is a constant function, use <a href="#val-retag"><code>retag</code></a> for even more efficiency.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-retag"><a href="#val-retag" class="anchor"></a><code><span><span class="keyword">val</span> retag : <span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>retag tag t</code> changes all tags within <code>t</code> to <code>tag</code> in O(1) time. It is equivalent to <a href="#val-map_tag"><code>map_tag</code></a><code> (fun _ -&gt; tag) t</code> but usually more efficient. The data remain intact.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-retag_subtree"><a href="#val-retag_subtree" class="anchor"></a><code><span><span class="keyword">val</span> retag_subtree : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>retag_subtree path tag t</code> changes all tags within the subtrie rooted at <code>path</code> to <code>tag</code> efficiently. The data remain intact.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-untag"><a href="#val-untag" class="anchor"></a><code><span><span class="keyword">val</span> untag : <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'data</span> <a href="#type-untagged">untagged</a></span></span></code></div><div class="spec-doc"><p><code>untag t</code> is <code>retag () t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set_of_tags"><a href="#val-set_of_tags" class="anchor"></a><code><span><span class="keyword">val</span> set_of_tags : <span><span>(<span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'tag</span> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'data</span>, <span class="type-var">'tag</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'tag</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>set_of_tags cmp t</code> returns the set of tags used in a trie, but as a <code>Seq.t</code>. <code>cmp</code> is the tag comparator for consolidating tags.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Untagged"><a href="#module-Untagged" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Untagged/index.html">Untagged</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
