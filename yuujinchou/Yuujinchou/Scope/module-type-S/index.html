<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>S (yuujinchou.Yuujinchou.Scope.S)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.3"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">yuujinchou</a> &#x00BB; <a href="../../index.html">Yuujinchou</a> &#x00BB; <a href="../index.html">Scope</a> &#x00BB; S</nav><header class="odoc-preamble"><h1>Module type <code><span>Scope.S</span></code></h1><p>The signature of scoping effects.</p></header><nav class="odoc-toc"><ul><li><a href="#types-of-effect-handlers">Types of Effect Handlers</a></li><li><a href="#exceptions">Exceptions</a></li><li><a href="#name-resolution">Name Resolution</a></li><li><a href="#inclusion-of-new-names">Inclusion of New Names</a></li><li><a href="#importing-of-new-names">Importing of New Names</a></li><li><a href="#modifying-namespaces">Modifying Namespaces</a></li><li><a href="#exporting-names">Exporting Names</a></li><li><a href="#sections">Sections</a></li><li><a href="#runners">Runners</a></li><li><a href="#debugging">Debugging</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Param"><a href="#module-Param" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Param/index.html">Param</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>A scope inherently has two namespaces: a <i>visible</i> namespace that dictates what's visible, and an <i>export</i> namespace recording all the names that will be exported.</p><h2 id="types-of-effect-handlers"><a href="#types-of-effect-handlers" class="anchor"></a>Types of Effect Handlers</h2><div class="odoc-spec"><div class="spec type anchored" id="type-not_found_handler"><a href="#type-not_found_handler" class="anchor"></a><code><span><span class="keyword">type</span> not_found_handler</span><span> = <span><span><a href="Param/index.html#type-context">Param.context</a> option</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>The type of a handler of the <a href="../../Modifier/module-type-S/Perform/index.html#val-not_found"><code>Modifier.S.Perform.not_found</code></a> effect.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-shadow_handler"><a href="#type-shadow_handler" class="anchor"></a><code><span><span class="keyword">type</span> shadow_handler</span><span> =
  <span><span><a href="Param/index.html#type-context">Param.context</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a></span></code></div><div class="spec-doc"><p>The type of a handler of the <a href="../../Modifier/module-type-S/Perform/index.html#val-shadow"><code>Modifier.S.Perform.shadow</code></a> effect.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-hook_handler"><a href="#type-hook_handler" class="anchor"></a><code><span><span class="keyword">type</span> hook_handler</span><span> =
  <span><span><a href="Param/index.html#type-context">Param.context</a> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Param/index.html#type-hook">Param.hook</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span></span></code></div><div class="spec-doc"><p>The type of a handler of the <a href="../../Modifier/module-type-S/Perform/index.html#val-hook"><code>Modifier.S.Perform.hook</code></a> effect.</p></div></div><h2 id="exceptions"><a href="#exceptions" class="anchor"></a>Exceptions</h2><div class="odoc-spec"><div class="spec exception anchored" id="exception-Locked"><a href="#exception-Locked" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Locked</span></span></code></div><div class="spec-doc"><p>The exception <code>Locked</code> is raised when an operation on a scope starts before another operation on the same scope is finished. This could happen when the user, for example, calls <a href="#val-modify_visible"><code>modify_visible</code></a> and then calls <a href="#val-modify_export"><code>modify_export</code></a> when handling the effects.</p><p>The principle is that one should not access any scope in its intermediate states, including looking up a name via <a href="#val-resolve"><code>resolve</code></a>. Any attempt to do so will raise the exception <code>Locked</code>; the exception <code>Locked</code> signals a serious programming error.</p><p>Note: <a href="#val-section"><code>section</code></a> only locks the parent scope; the child scope is initially unlocked.</p></div></div><h2 id="name-resolution"><a href="#name-resolution" class="anchor"></a>Name Resolution</h2><div class="odoc-spec"><div class="spec value anchored" id="val-resolve"><a href="#val-resolve" class="anchor"></a><code><span><span class="keyword">val</span> resolve : <span><a href="../../Trie/index.html#type-path">Trie.path</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>resolve p</code> looks up the name <code>p</code> in the visible namespace and returns the data associated with the binding.</p></div></div><h2 id="inclusion-of-new-names"><a href="#inclusion-of-new-names" class="anchor"></a>Inclusion of New Names</h2><p>Inclusion affects both visible and export namespaces, just like <code>include</code> in OCaml.</p><div class="odoc-spec"><div class="spec value anchored" id="val-include_singleton"><a href="#val-include_singleton" class="anchor"></a><code><span><span class="keyword">val</span> include_singleton : 
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_export</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Trie/index.html#type-path">Trie.path</a> * <span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>include_singleton (p, x)</code> adds a new binding to both the visible and export namespaces, where the binding is associating the data <code>x</code> to the path <code>p</code>. Conflicting names during the final merge will trigger the effect <code>shadow</code>. <code>include_singleton (p, x)</code> is equivalent to <code>include_subtree Trie.(singleton (p, x))</code>, but potentially more efficient.</p><p>When implementing an OCaml-like language, this is how one can introduce a top-level definition <code>let p = x</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_visible</span> <p>The context of modifier effects when merging the subtree into the visible namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_export</span> <p>The context of modifier effects when merging the subtree into the export namespace.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-include_subtree"><a href="#val-include_subtree" class="anchor"></a><code><span><span class="keyword">val</span> include_subtree : 
  <span><span class="optlabel">?context_modifier</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_export</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?modifier</span>:<span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Trie/index.html#type-path">Trie.path</a> * <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>include_subtree (p, ns)</code> merges the namespace <code>ns</code> prefixed with <code>p</code> into both the visible and export namespaces. Conflicting names during the final merge will trigger the effect <code>shadow</code>.</p><p>This feature is useful for introducing multiple top-level definitions at once.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_modifier</span> <p>The context of modifier effects when applying <code>modifier</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_visible</span> <p>The context of modifier effects when merging the subtree into the visible namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_export</span> <p>The context of modifier effects when merging the subtree into the export namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifier</span> <p>The modifier applied to the subtree before importing it. The default value is <a href="../../Language/index.html#val-id"><code>Language.id</code></a>.</p></li></ul></div></div><h2 id="importing-of-new-names"><a href="#importing-of-new-names" class="anchor"></a>Importing of New Names</h2><p>Importing affects only the visible namespace, just like <code>open</code> in OCaml.</p><div class="odoc-spec"><div class="spec value anchored" id="val-import_singleton"><a href="#val-import_singleton" class="anchor"></a><code><span><span class="keyword">val</span> import_singleton : 
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Trie/index.html#type-path">Trie.path</a> * <span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>import_singleton (p, x)</code> adds a new binding to the visible namespace (while keeping the export namespace intact), where the binding is associating the data <code>x</code> to the path <code>p</code>. Conflicting names during the final merge will trigger the effect <code>shadow</code>. <code>import_singleton (p, x)</code> is equivalent to <code>import_subtree Trie.(singleton (p, x))</code>, but potentially more efficient.</p><p>When implementing an OCaml-like language, one can implement the local binding <code>let p = x in e</code> as follows:</p><pre class="language-ocaml"><code>section [] @@ fun () -&gt;
import_singleton (p, x);
(* code for handling the expression [e] *)</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_visible</span> <p>The context of modifier effects when merging the subtree into the visible namespace.</p></li></ul><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.0.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-import_subtree"><a href="#val-import_subtree" class="anchor"></a><code><span><span class="keyword">val</span> import_subtree : 
  <span><span class="optlabel">?context_modifier</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?modifier</span>:<span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../Trie/index.html#type-path">Trie.path</a> * <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>import_subtree (p, ns)</code> merges the namespace <code>ns</code> prefixed with <code>p</code> into the visible namespace (while keeping the export namespace intact). Conflicting names during the final merge will trigger the effect <code>shadow</code>.</p><p>When implementing an OCaml-like language, one can import content from other compilation units using <code>import_subtree</code>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_modifier</span> <p>The context of modifier effects when applying <code>modifier</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_visible</span> <p>The context of modifier effects when merging the subtree into the visible namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifier</span> <p>The modifier applied to the subtree before importing it. The default value is <a href="../../Language/index.html#val-id"><code>Language.id</code></a>.</p></li></ul></div></div><h2 id="modifying-namespaces"><a href="#modifying-namespaces" class="anchor"></a>Modifying Namespaces</h2><div class="odoc-spec"><div class="spec value anchored" id="val-modify_visible"><a href="#val-modify_visible" class="anchor"></a><code><span><span class="keyword">val</span> modify_visible : 
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>modify_visible m</code> modifies the visible namespace by running the modifier <code>m</code> on it, using the internal modifier engine.</p><p>When implementing an OCaml-like language, one can implement <code>open M</code> as follows:</p><pre class="language-ocaml"><code>modify_visible Language.(union [id; renaming [&quot;M&quot;] []])</code></pre><p>When implementing an OCaml-like language, one can implement <code>include M</code> as follows:</p><pre class="language-ocaml"><code>export_visible Language.(renaming [&quot;M&quot;] []);
modify_visible Language.(union [id; renaming [&quot;M&quot;] []])</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context</span> <p>The context of modifier effects.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify_export"><a href="#val-modify_export" class="anchor"></a><code><span><span class="keyword">val</span> modify_export : 
  <span><span class="optlabel">?context_export</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>modify_export m</code> modifies the export namespace by running the modifier <code>m</code> on it, using the internal modifier engine.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_export</span> <p>The context of modifier effects.</p></li></ul></div></div><h2 id="exporting-names"><a href="#exporting-names" class="anchor"></a>Exporting Names</h2><div class="odoc-spec"><div class="spec value anchored" id="val-export_visible"><a href="#val-export_visible" class="anchor"></a><code><span><span class="keyword">val</span> export_visible : 
  <span><span class="optlabel">?context_modifier</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_export</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>export_visible m</code> runs the modifier <code>m</code> on the visible namespace, and then merge the result into the export namespace. Conflicting names during the final merge will trigger the effect <code>shadow</code>.</p><p>This feature is useful for implementing a userspace <code>export</code> statement. It does not exist in OCaml-like languages.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_modifier</span> <p>The context of modifier effects when applying the modifier <code>m</code>.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_export</span> <p>The context of modifier effects when merging the subtree into the export namespace.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_visible"><a href="#val-get_visible" class="anchor"></a><code><span><span class="keyword">val</span> get_visible : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span></span></code></div><div class="spec-doc"><p><code>get_visible ()</code> returns the visible namespace of the current scope.</p><p>This is useful for obtaining all visible names for auto-completion. It can also be used for checking whether a shadowed definition is still visible under another name. (However, scanning the entire visible namespace is expensive and should probably be avoided.)</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.2.0</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_export"><a href="#val-get_export" class="anchor"></a><code><span><span class="keyword">val</span> get_export : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span></span></code></div><div class="spec-doc"><p><code>get_export ()</code> returns the export namespace of the current scope.</p><p>This is useful for obtaining all exported content when wrapping up a compilation unit. The <a href="#val-section"><code>section</code></a> function internally calls <code>get_export</code> when wrapping up a child scope, but an implementer is expected to call <code>get_export</code> for the outermost scope. The outermost scope is special because it is the interface of the entire compilation unit and its ending often triggers special handling code (<i>e.g.,</i> caching of declared names for faster scope checking).</p></div></div><h2 id="sections"><a href="#sections" class="anchor"></a>Sections</h2><div class="odoc-spec"><div class="spec value anchored" id="val-section"><a href="#val-section" class="anchor"></a><code><span><span class="keyword">val</span> section : 
  <span><span class="optlabel">?context_modifier</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_visible</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?context_export</span>:<a href="Param/index.html#type-context">Param.context</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?modifier</span>:<span><a href="Param/index.html#type-hook">Param.hook</a> <a href="../../Language/index.html#type-t">Language.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../Trie/index.html#type-path">Trie.path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>section p f</code> starts a new scope and runs the thunk <code>f</code> within the scope. The child scope inherits the visible namespace from the parent, and its export namespace will be prefixed with <code>p</code> and merged into both the visible and export namespaces of the parent scope.</p><p>A section is similar to a section in Coq or a module in Agda (but not a module in OCaml). This can be used to implement local bindings as well; a local binding is a private definition in a section. For example, in an OCaml-like languages augmented with sections,</p><pre class="language-ocaml"><code>let y = let x = 1 in x</code></pre><p>is equivalent to</p><pre>section {
  private let x = 1
  let y = x
} // this section exports y but not x</pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_modifier</span> <p>The context of modifier effects when applying <code>modifier</code> to the content of the section before the merging.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_visible</span> <p>The context of modifier effects when merging the content of the section into its parent's visible namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">context_export</span> <p>The context of modifier effects when merging the content of the section into its parent's export namespace.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">modifier</span> <p>The modifier applied to the content of the section before the merging. The default value is <a href="../../Language/index.html#val-id"><code>Language.id</code></a>.</p></li></ul></div></div><h2 id="runners"><a href="#runners" class="anchor"></a>Runners</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-Perform"><a href="#module-type-Perform" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Perform/index.html">Perform</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature of a module implementing all effect handlers for a lexical scope.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Perform"><a href="#module-Perform" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Perform/index.html">Perform</a></span><span> : <a href="module-type-Perform/index.html">Perform</a></span></code></div><div class="spec-doc"><p>The handlers that (re-)perform effects.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Silence"><a href="#module-Silence" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Silence/index.html">Silence</a></span><span> : <a href="module-type-Perform/index.html">Perform</a></span></code></div><div class="spec-doc"><p>The handlers that silence effects. All the triggers actually do nothing.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run"><a href="#val-run" class="anchor"></a><code><span><span class="keyword">val</span> run : 
  <span><span class="optlabel">?not_found</span>:<a href="#type-not_found_handler">not_found_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?shadow</span>:<a href="#type-shadow_handler">shadow_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?hook</span>:<a href="#type-hook_handler">hook_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?export_prefix</span>:<a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?init_visible</span>:<span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>run ~not_found ~shadow ~hook f</code> initializes a scope and executes the thunk <code>f</code>, using <code>h</code> to handle modifier effects.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">not_found</span> <p>See <a href="../../Modifier/module-type-S/index.html#val-run"><code>Yuujinchou.Modifier.S.run</code></a> for the explanation of this argument.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">shadow</span> <p>See <a href="../../Modifier/module-type-S/index.html#val-run"><code>Yuujinchou.Modifier.S.run</code></a> for the explanation of this argument.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">hook</span> <p>See <a href="../../Modifier/module-type-S/index.html#val-run"><code>Yuujinchou.Modifier.S.run</code></a> for the explanation of this argument.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">export_prefix</span> <p>The additional global prefix prepended to the paths reported to effect handlers originating from export namespaces. The default is the empty path (<code>Emp</code>). This does not affect paths originating from visible namespaces.</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">init_visible</span> <p>The initial visible namespace. The default is the empty namespace.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_with"><a href="#val-try_with" class="anchor"></a><code><span><span class="keyword">val</span> try_with : 
  <span><span class="optlabel">?not_found</span>:<a href="#type-not_found_handler">not_found_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?shadow</span>:<a href="#type-shadow_handler">shadow_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?hook</span>:<a href="#type-hook_handler">hook_handler</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Execute the code and handles the internal modifier effects.</p><p><code>try_with</code> is intended to be used within <a href="#val-run"><code>run</code></a> to intercept or reperform internal effects, while <a href="#val-run"><code>run</code></a> is intended to be at the top-level to set up the environment and handle all effects by itself. For example, the following function silences the <code>shadow</code> effects, but the silencing function should be used within the dynamic scope of a <a href="#val-run"><code>run</code></a>. See also <a href="../../Modifier/module-type-S/index.html#val-try_with"><code>Yuujinchou.Modifier.S.try_with</code></a>.</p><pre class="language-ocaml"><code>let silence_shadow f =
  try_with ~shadow:Silence.shadow f</code></pre><p>A consequence of the semantic difference between <a href="#val-run"><code>run</code></a> and <code>try_with</code> is that <a href="#val-run"><code>run</code></a> starts a fresh empty scope while <code>try_with</code> stays in the current scope.</p></div></div><h2 id="debugging"><a href="#debugging" class="anchor"></a>Debugging</h2><div class="odoc-spec"><div class="spec value anchored" id="val-register_printer"><a href="#val-register_printer" class="anchor"></a><code><span><span class="keyword">val</span> register_printer : 
  <span><span>(<span><span>[ <span>`NotFound of <span><a href="Param/index.html#type-context">Param.context</a> option</span> * <a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a></span>
   <span><span>| `Shadow</span> of
     <span><a href="Param/index.html#type-context">Param.context</a> option</span>
     * <a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a>
     * <span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span>
     * <span>(<a href="Param/index.html#type-data">Param.data</a> * <a href="Param/index.html#type-tag">Param.tag</a>)</span></span>
   <span><span>| `Hook</span> of
     <span><a href="Param/index.html#type-context">Param.context</a> option</span>
     * <a href="../../Trie/index.html#type-bwd_path">Trie.bwd_path</a>
     * <a href="Param/index.html#type-hook">Param.hook</a>
     * <span><span>(<a href="Param/index.html#type-data">Param.data</a>, <a href="Param/index.html#type-tag">Param.tag</a>)</span> <a href="../../Trie/index.html#type-t">Trie.t</a></span></span> ]</span> <span class="arrow">&#45;&gt;</span></span>
    <span>string option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>register_printer f</code> registers a printer <code>p</code> via <code>Printexc.register_printer</code> to convert unhandled internal effects into strings for the OCaml runtime system to display. See <a href="../../Modifier/module-type-S/index.html#val-register_printer"><code>Yuujinchou.Modifier.S.register_printer</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 5.1.0</li></ul></div></div></div></body></html>
