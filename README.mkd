# Yuujinchou: Name Manipulation Combinators

_Yuujinchou_ is a tiny OCaml combinator library for manipulating names. It was motivated by the practical need in implementing the `import` or `include` statements that are present in almost all programming languages. Here are some examples of such statements:
```agda
open import M -- Agda
```
```python
import foo # Python
```
The ability to import content from other files is a prerequisite of organizing large-scale software. However, it also brings up new design issues: how could programmers avoid imported content from colliding or shadowing the content in the current scope? For example, maybe in the current scope we have defined a function called `test`, and do not want to import another function also called `test`. To address this, many programming languages allow programmers to selectively hide or rename part of the imported content:
```agda
open import M renaming (a to b) public -- renaming a to b, and then re-exporting the content
```
```python
import foo as bar # putting content of foo under the prefix bar
```
We can treat the hiding or renaming as a partial function from names to names. One can take this aspect seriously and vastly generalize the mechanism into a fully-fledged combinator library. This library is the result of such thinking---a concise yet powerful (perhaps overkilling) combinator language for manipulating names in programming languages.

## Technical Overview

We assume names are hierarchical and can be encoded as lists of strings. For example, the name `a.b` is represented as an OCaml list `["a"; "b"]`.
The result of pattern matching is one of the following:

1. ```Ok `NoMatch```: the pattern runs successfully but does not match the name.
2. ```Ok `Matched [(name1, `Public); (name2, `Private); ...]```: the pattern matches the name but it was renamed into other names, with tags showing whether a particular new name should be re-exported (``` `Public```) or not (``` `Private```). It is possible that the set of new names is empty despite the old name being matched because we support the intersection (meet) operator.
3. ```Error error```: the pattern is ill-formed.

Here is the type of the pattern:
```ocaml
type exportability = [`Public | `Private]
type path = string list
type pattern =
  | PatWildcard
  | PatScope of path * path option * pattern
  | PatSeq of pattern list
  | PatInv of pattern
  | PatExport of exportability * pattern
  | PatJoin of pattern list
```
We will explain each combinator, one by one. Before moving on, you will need to understand the concept "mode" when running the engine:

### Modes

There are two modes of the pattern matching engine: the _normal_ mode and the _inverse_ mode. The motivation to have the inverse mode is to hide names from being imported. Think about the pattern `a.b`, which would normally select the name `a.b` from the imported content. Its dual meaning---selecting everything _other than_ the name `a.b`---is exactly the hiding operator we are looking for. The inverse mode has been extended to all combinators and the details are explained below. It is recommended to study how the combinators operate under the normal mode first.

### Exportability

Exportability is either ``` `Public``` (meaning the name should be re-exported) or ``` `Private``` (meaning the name should not be re-exported). The programmer needs to supply the default exportability when running the engine, and the output of the engine will tag each new name with computed exportability as shown above.

## Wildcard Pattern (`PatWildcard`)

The wildcard pattern `PatWildcard` under the normal mode matches every name except for the root (the empty list `[]`). The same pattern under the inverse mode matches nothing but the root (the empty list `[]`). In either case, if a name `p` is matched, then the output is `Ok (Match [p, e])` where `e` is the inherited default exportability.

## Scope Renaming Pattern (`PatScope`)

The pattern `PatScope (p, None, pattern)` under the normal mode matches any name with the prefix `p` and then runs `pattern` against the residual part of the name. For example, `Pat (["a"; "b"], PatWildcard)` will match the name `a.b.c` (represented by `["a"; "b"; "c"]`) because it will first match the prefix `["a"; "b"]` and then the pattern `PatWildcard` will match the remaining part `c`. The same pattern under the inverse mode will match any name whose prefix is not `p` or any name that fails to match `pattern` after removing the prefix `p`. If particular, `PatScope ([], None, PatWildcard)` will match all names, including the root (the empty list `[]`), which is different from `PatWildcard` which will exclude the root (the empty list `[]`).

The pattern `PatScope (p, Some r, pattern)` is the same as `PatScope (p, None, pattern)` expect that the prefix `p`, if matched, will be replaced by `r`. The same pattern under the inverse mode will result into an error because the replacement `r` would not be used.

## Sequencing Combinator (`PatSeq`)

The pattern `PatSeq [pattern_1; pattern_2; ...; pattern_n]` under the normal mode runs the patterns `pattern_1`, `pattern_2`, ..., `pattern_n` in order. New names generated by previous patterns (through the scope renaming operator `PatScope`) are used in later patterns. A name is matched if it is matched by any pattern in the sequence. It is possible that a name is renamed into multiple names during the process, and these renamings are merged by taking the union of all possible renamings, where conflicting exportabilities are resolved by the join operation (that is, ``` `Public``` and ``` `Private``` are merged into ``` `Public```). As a special case, `PatSeq []` under the normal mode matches every name.

The pattern `PatSeq [pattern_1; pattern_2; ...; pattern_n]` under the inverse mode also runs the patterns `pattern_1`, `pattern_2`, ..., `pattern_n` in order, but with a twist: a name is matched only if it is matched by all patterns in the sequence. Overlapping renamings and conflicting exportabilities are resolved by taking the unions and joins as well. As a special case, `PatSeq []` under the inverse mode matches nothing.

## Inversion Combinator (`PatInv`)

The pattern `PatInv pat` flips the current mode of the engine (from the normal mode to the inverse mode and vice versa) and proceed with the pattern `pat`.

## Exportability Assignment Combinator (`PatExport`)

The pattern `PatExport (e, pat)` changes the default exportability to `ex` (which could be either ``` `Public``` or ``` `Private```) of the engine before running the pattern `pat`.

## Join Combinator (`PatJoin`)

`PatJoin [pattern_1; pattern_2; ...; pattern_n]` under the normal mode runs the subpatterns independently and takes the join of the renaming relations. The same pattern under the inverse mode takes the meet of the renaming relations instead.

There is one trick case about the meet operation. Assume we have two different names `x` and `y`. The meet of ``` `Matched [x, `Public]``` and ``` `Matched [y, `Public]``` is ``` `Matched []```, not ``` `NoMatch```. It means the name is matched but there are no new names for it.

## Examples
